options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Calculator)


public class Calculator

   private int errorsCounter = 0;
{
    public static void main(String args[]) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		Calculator myCalc = new Calculator(System.in);
		SimpleNode root = myCalc.Expression(); // returns reference to root node
        	
		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
	
}

PARSER_END(Calculator)

SKIP :
{
	" " | "\r" | "\t"
}

TOKEN:
{
     <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >
   | 	<INTEGER: (["0"-"9"])+ >
   |  <LF: "\n" >
   |  <IF: "if" >
   |  <ELSE: "else" >
   |  <WHILE: "while" >
   |  <PUBLIC: "public" >
   |  <NEW: "new" >
   |  <INT: "int" >
   |  <TRUE: "true" >
   |  <FALSE: "false" >
   |  <THIS: "this" >
   |  <VOID: "void" >
   |  <MAIN: "main" >
   |  <STRING: "String" >
   |  <CLASS: "class" >
   |  <INTERFACE: "interface" >  //???
   |  <STATIC: "static" >
   |  <LENGTH: "length" >
   |  <RETURN: "return" >
   |  <IMPORT: "import" >
   |  <BOOLEAN: "boolean" >
   |  <EXTENDS: "extends" >
   |  <LBRACKET: "{" >
   |  <RBRACKET: "}" >
   |  <LPAR: "(" >
   |  <RPAR: ")" >
   |  <LSQRBRACKET: "[" >
   |  <RSQRBRACKET: "]" >
   |  <SEMICOLON: ";" >
   |  <COMMA: "," >
   |  <EQUALS: "=" >
   |  <AND: "&&" >
   |  <OR: "||" >  //É para usar??
   |  <LESS: "<" >
   |  <MORE: ">" >  //É para usar??
   |  <PLUS: "+" >
   |  <MINUS: "-" >
   |  <MUL: "*" >
   |  <DIV: "/" >
   |  <DOT: "." >
   |  <NOT: "!" >
   |  <INLINECOMMENT: "//" >
   |  <STARTCOMMENTBLOCK: "/*" >
   |  <ENDCOMMENTBLOCK: "/*" >
}

SimpleNode Program(): {}
{
   this.errorsCounter = 0;
   try {
      ImportDeclaration() ClassDeclaration() <EOF> 
   } catch(Exception e) {
      this.errorsCounter++;
      if(this.errorsCounter == 10) //END PROGRAM
   }

   {return jjtThis;} // Java code inside brackets
}

void ImportDeclaration(): {}
{
   (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration(): {}
{
   <CLASS> , <IDENTIFIER> , [ <EXTENDS> , <IDENTIFIER> ]? , <LBRACKET> , ( VarDeclaration() )* , ( MethodDeclaration() )* , <RBRACKET>
}

void VarDeclaration(): {}
{
   Type() Identifier(), <SEMICOLON>
}

void MethodDeclaration(): {}
{
   <PUBLIC> Type() Identifier() <LPAR> [ Type() Identifier() ( <COMMA> Type() Identifier() )* ]? <RPAR> <LBRACKET> ( VarDeclaration() )* ( Statement() )* <RETURN> Expression() <SEMICOLON> <RBRACKET>
   | <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQRBRACKET> <RSQRBRACKET> Identifier() <RPAR> <LBRACKET> ( VarDeclaration() )* ( Statement() )* <RBRACKET>
}

void Type() #void: {}
{
   <INT>, <LSQRBRACKET>, <RSQRBRACKET>
   | <BOOLEAN>
   | <INT>
   | <IDENTIFIER>
}

void Statement() #void: {}
{
   <LBRACKET> ( Statement() )* <RBRACKET>
   | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
   | <WHILE> <RPAR> Expression() <LPAR> Statement()
   | Expression() <SEMICOLON>
   | <IDENTIFIER> <EQUALS> Expression() <SEMICOLON>
   | <IDENTIFIER> <LSQRBRACKET> Expression() <RSQRBRACKET> <EQUALS> Expression() <SEMICOLON>
}


void Expression() #void{}
{
   Expression() , ( <AND> | <LESS> | <PLUS> | <MINUS> | <MUL> | <DIV> )* , Expression() 
   | Expression() , <LSQRBRACKET> , Expression() , <RSQRBRACKET> 
   | Expression() , <DOT> , <LENGTH> 
   | Expression() , <DOT> , <IDENTIFIER> , <LPAR> , [ Expression() , ( <COMMA> , Expression() )* ]? , <RPAR>
   | <INTEGER>
   | <TRUE>
   | <FALSE>
   | <IDENTIFIER>
   | <THIS>
   | <NEW> , <INT> , <LSQRBRACKET> , Expression() , <RSQRBRACKET>
   | <NEW> , <IDENTIFIER> , <LPAR> , <RPAR>
   | <NOT> , Expression() 
   | <LPAR> , Expression() , <RPAR>
   
}



