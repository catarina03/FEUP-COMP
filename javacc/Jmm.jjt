options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Jmm)

import pt.up.fe.comp.jmm.report.*;
import java.util.ArrayList;

public class Jmm{

   public int errorCounter = 0;
   public ArrayList<Report> reports = new ArrayList<Report>();


   public static void main(String args[]) throws ParseException {
      System.out.println("Write an arithmetic expression:");
      Jmm myJmm = new Jmm(System.in);
      //SimpleNode root = myJmm.Program(); // returns reference to root node
      SimpleNode root = myJmm.While(); // returns reference to root node
         
      root.dump(""); // prints the tree on the screen

      //System.out.println("Expression value: "+myJmm.eval(root));
   }

   //Not needed bc reports is public
   /*
   public ArrayList<Report> getReports(){
      return reports;
   }
   */
	
}

PARSER_END(Jmm)

SKIP :
{
	" " | "\r" | "\t" | "\n" | <"//"(~[ "\n", "\r" ]) * ("\n" | "\r" | "\r\n")>  
   |  <"/*" (~["*"])* "*" ("*" | ~[ "*", "/" ](~["*"])* "*")* "/">
}



TOKEN:
{ 
   <INTEGER: (["0"-"9"])+ >
  // |  <LF: "\n" >
   |  <IF: "if" >
   |  <ELSE: "else" >
   |  <WHILE: "while" >
   |  <PUBLIC: "public" >
   |  <NEW: "new" >
   |  <INT: "int" >
   |  <TRUE: "true" >
   |  <FALSE: "false" >
   |  <THIS: "this" >
   |  <VOID: "void" >
   |  <MAIN: "main" >
   |  <STRING: "String" >
   |  <CLASS: "class" >
   |  <STATIC: "static" >
   |  <LENGTH: "length" >
   |  <RETURN: "return" >
   |  <IMPORT: "import" >
   |  <BOOLEAN: "boolean" >
   |  <EXTENDS: "extends" >
   |  <LBRACKET: "{" >
   |  <RBRACKET: "}" >
   |  <LPAR: "(" >
   |  <RPAR: ")" >
   |  <LSQRBRACKET: "[" >
   |  <RSQRBRACKET: "]" >
   |  <SEMICOLON: ";" >
   |  <COMMA: "," >
   |  <EQUALS: "=" >
   |  <AND: "&&" >
   |  <LESS: "<" >
   |  <PLUS: "+" >
   |  <MINUS: "-" >
   |  <MUL: "*" >
   |  <DIV: "/" >
   |  <DOT: "." >
   |  <NOT: "!" >
   | <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >
   // |  <INLINECOMMENT: "//" >
   // |  <STARTCOMMENTBLOCK: "/*" >
   // |  <ENDCOMMENTBLOCK: "*/" >
 //  |  <IDENTIFIEROBJECT: ["A"-"Z"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >
   //|  <IDENTIFIER: ["a"-"z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >

}

SimpleNode Program(): {}
{
   try {
      ImportDeclaration() ClassDeclaration() <EOF> 
   } catch(Exception e) {
        e.printStackTrace();
   }

   {return jjtThis;} // Java code inside brackets
}

void ImportDeclaration(): {}
{
   ( <IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER> )* <SEMICOLON> )*
}

void ClassDeclaration() #Class : {}
{
   <CLASS> <IDENTIFIER> ( <EXTENDS> <IDENTIFIER> #Extends )? <LBRACKET> ( VarDeclaration() )* ( MethodDeclaration() )* <RBRACKET>
}

void VarDeclaration() #VarDeclaration: {}
{
   Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() #MethodDeclaration: {}
{
   <PUBLIC>
   (
      (
          Type() <IDENTIFIER> <LPAR> ( Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* )? #Parameters <RPAR>
          <LBRACKET>
              MethodBody()
              <RETURN> Expression() #Return <SEMICOLON>
          <RBRACKET>
      )
      |
      (
          <STATIC> <VOID> <MAIN> #Main <LPAR> <STRING> <LSQRBRACKET> <RSQRBRACKET> <IDENTIFIER> <RPAR> #MainParameters
          <LBRACKET>
              MethodBody()
          <RBRACKET>
      )
   )

}

void MethodBody() #MethodBody: {}
{
    ( LOOKAHEAD(2) VarDeclaration() )* ( Statement() )*
}

void Type() #void: {}
{
   <INT> ( <LSQRBRACKET> <RSQRBRACKET> )? #IntArrayVar
   | <BOOLEAN> #BooleanVar
   | <IDENTIFIER> #TypeID
}


void Statement() #void: {}
{
   StatementWithID() | StatementWithoutID()
}

void StatementWithID() #void : {}
{
   <IDENTIFIER>   
   (  
      ( <EQUALS> Expression() <SEMICOLON> #VarAssignment )
   | 
      ( <LSQRBRACKET> Expression() <RSQRBRACKET> <EQUALS> Expression() <SEMICOLON> #ArrayAssignment )
   |
      ( ExpressionDOT() <SEMICOLON> )
   )
}

void StatementWithoutID() #void : {}
{
   While() 
   | IfElse()
   | <LBRACKET> ( Statement() )* <RBRACKET>
   | ExpressionWithoutID() <SEMICOLON>
}

void Condition() #Condition: {}
{
   <LPAR> Expression() <RPAR>
}

void IfElse() #If : {}
{
   <IF> Condition() Statement() <ELSE> Statement()
}

SimpleNode While() #While : {}
{
   <WHILE>
   try {
      <LPAR> Expression() <RPAR>
   } catch (ParseException e) {
      this.errorCounter++;
      reports.add(new Report(ReportType.ERROR, Stage.SYNTATIC, getToken(0).beginLine ,e.getMessage()));
      System.out.println(this.errorCounter);

      System.out.println("Exception on WHILE CONDITION caught.");
      
      error_skipto(RPAR);

      if(this.errorCounter == 10){
         throw e;
      }


   }
   Statement()


   {return jjtThis;} // Java code inside brackets
}



void Expression() #void :{}
{
   ExpressionSwitchFromAND() ExpressionAND()
}

void ExpressionAND() #void :{}         
{
   ( <AND> ExpressionSwitchFromAND() #And ExpressionAND() )
   | 
   {}
}

void ExpressionSwitchFromAND() #void: {}        
{
   ExpressionSwitchFromLESS() ExpressionLESS() 
}

void ExpressionLESS() #void :{}           
{
   ( <LESS> ExpressionSwitchFromLESS() #Less ExpressionLESS() )
   | 
   {}
}

void ExpressionSwitchFromLESS() #void : {}         
{
   ExpressionSwitchFromPLUS() ExpressionPLUS()
}

void ExpressionPLUS() #void :{}            
{
   ( <PLUS> ExpressionSwitchFromPLUS() #Plus ExpressionPLUS() )
   | 
   {}
}

void ExpressionSwitchFromPLUS() #void :{}      
{
   ExpressionSwitchFromMINUS() ExpressionMINUS() 
}


void ExpressionMINUS() #void :{}           
{
   ( <MINUS> ExpressionSwitchFromMINUS() #Minus ExpressionMINUS() )
   | 
   {}
}

void ExpressionSwitchFromMINUS() #void :{}      
{
   ExpressionSwitchFromMUL() ExpressionMUL() 
}

void ExpressionMUL() #void :{}              
{
   ( <MUL> ExpressionSwitchFromMUL() #Mul ExpressionMUL() )
   | 
   {}
}

void ExpressionSwitchFromMUL() #void :{}     
{
   ExpressionSwitchFromDIV() ExpressionDIV() 
}

void ExpressionDIV() #void :{}                
{
   ( <DIV> ExpressionSwitchFromDIV() #Div ExpressionDIV() )
   | 
   {}
}

void ExpressionSwitchFromDIV() #void : {}
{
   ExpressionSwitchFromDOT() ExpressionDOT()
}

void ExpressionDOT() #void: {}
{
    (
       <DOT>
       (
           <LENGTH>
       |
          ( <IDENTIFIER> <LPAR>
             ( Expression()
                ( <COMMA> Expression() )*
             )?
             <RPAR>
          )
       ) #DotMethodCall
       ExpressionArrayIndexing() ExpressionDOT()
   )
   | 
   {}
}

void ExpressionSwitchFromDOT() #void: {}
{
   ExpressionTerminal() ExpressionArrayIndexing()
}

//TODO: verificar se esta anotação AST funciona!!! e fica no sítio correto
void ExpressionArrayIndexing() #void :{}
{
   ( <LSQRBRACKET> Expression() <RSQRBRACKET> #ArrayAccess ExpressionArrayIndexing() )
   |
   {}
}


//Expressions without ids
void ExpressionWithoutID() #void : {}
{
    ExpressionSwitchFromANDWithoutID() ExpressionAND()
}

void ExpressionSwitchFromANDWithoutID() #void : {}
{
    ExpressionSwitchFromLESSWithoutID() ExpressionLESS()
}

void ExpressionSwitchFromLESSWithoutID() #void : {}
{
    ExpressionSwitchFromPLUSWithoutID() ExpressionPLUS()
}

void ExpressionSwitchFromPLUSWithoutID() #void : {}
{
    ExpressionSwitchFromMINUSWithoutID() ExpressionMINUS()
}

void ExpressionSwitchFromMINUSWithoutID() #void : {}
{
    ExpressionSwitchFromMULWithoutID() ExpressionMUL()
}

void ExpressionSwitchFromMULWithoutID() #void : {}
{
    ExpressionSwitchFromDIVWithoutID() ExpressionDIV()
}

void ExpressionSwitchFromDIVWithoutID() #void : {}
{
    ExpressionSwitchFromDOTWithoutID() ExpressionDOT()
}

void ExpressionSwitchFromDOTWithoutID() #void: {}
{
    ExpressionTerminalWithoutID() ExpressionArrayIndexing()
}


//TERMINAL BLOCKS

void ExpressionTerminal() #void : {}
{
   ExpressionTerminalWithoutID()
   |
   <IDENTIFIER>
}

void ExpressionTerminalWithoutID() #void : {}
{
   <INTEGER>
      | <TRUE> #BooleanTrue
      | <FALSE>  #BooleanFalse
      | <THIS> #This
      | <NEW> 
      ( 
         ( <INT> <LSQRBRACKET> Expression() <RSQRBRACKET> ) #IntArrayVar   //TODO: verificar se esta anotação fica bem aqui (repetida em cima)
        |
         ( <IDENTIFIER> <LPAR> <RPAR> ) #TypeObject
      ) #New
      | <NOT> Expression() #Not
      | <LPAR> Expression() <RPAR>
}


JAVACODE
void error_skipto(int kind) {
   // ParseException e = generateParseException();  // generate the exception object
   // System.out.println(e.toString());  // print the error message
  
   Token t;
   // consume tokens all the way up to a token of "kind" - use a do-while loop
   // rather than a while because the current token is the one immediately before
   // the erroneous token (in our case the token immediately before what should
   // have been "if"/"while".
   do {
      t = getNextToken();

      System.out.println(t.image);

      if(t.kind == LPAR){
         error_skipto(RPAR);
      }
   }
   while (t.kind != kind && t.kind != EOF);
}
